function obj = rtRealisticThroughLens(obj, rays, nLines)
% Rays at the entrance aperture are traced to the exit aperture
%
%  lens.rtRealisticThroughLens(rays,nLines)
%
% ray structure
%   nLines specifies rendering options
%     This can be a structure with the fields
%       .spacing ('uniform' or 'random')
%       .numLines (how many lines)
%     This can be a number
%       <= 0 means don't draw the lines; any other positive
%     number describes how many to draw.
%
% The initial rays are generated by a call to lens.rtSourceToEntrance,
% which takes a point input and generates the ray positions and angles at
% the entrance aperture.
%
% On return, these rays are changed to be the position and direction of the
% rays at the exit aperture.
%
% This should be handled, in the end, by a linear transform following our
% analysis of the lens ABCD matrices and lightfields.
%
% See also psfCameraC.estimatePSF
%
%   In that routine, one can ask that the lines be extended to
%   the film plane by setting a flag.  The flag adds a final
%   surface in the film plane to the surfaceArray
%
% TODO:  Simplify this code and add comments.
%        Especially, use the Wigner/Light field ideas
%
% AL, Vista team, 2013

% Ray trace calculation starts here
%
% The order is from furthest from film to film, which is also
% how the rays pass through the optics.


% passedCenterAperture = false;  %true if rays are traced through lens aperture

% How many rays
nRays = rays.get('n rays');
prevN = ones(nRays, 1);

% For each surface element (lenses and apertures).
nSurfaces = obj.get('numels');

% Which sample rays to visualize
if ~isstruct(nLines),                     samps = randi(nRays,[nLines,1]);
elseif strcmp(nLines.spacing, 'uniform'), samps = round(linspace(1, nRays, nLines.numLines));
elseif strcmp(nLines.spacing,'random'),   samps = randi(nRays,[nLines.numLines,1]);
else    error('Unknown spacing parameter %s\n',nLines.spacing);
end
rays.drawSamples = samps;

for lensEl = 1:nSurfaces
    % Get the surface data
    curEl = obj.surfaceArray(lensEl);
    curAperture = curEl.apertureD/2;
    
    % Calculate ray intersection position with lens element or
    % aperture. In the case of a 0 curvature, the direction
    % does not change.
    %
    % This uses the vector form of Snell's Law:
    % http://en.wikipedia.org/wiki/Snell's_law
    if (curEl.sRadius ~= 0)
        
        % Spherical element
        repCenter = repmat(curEl.sCenter, [nRays 1]);
        repRadius = repmat(curEl.sRadius, [nRays 1]);
        
        % Radicand from vector form of Snell's Law
        radicand = dot(rays.direction, rays.origin - repCenter, 2).^2 - ...
            ( dot(rays.origin - repCenter, rays.origin -repCenter, 2)) + repRadius.^2;
        
        % Calculate something about the ray angle with respect
        % to the current surface.  AL to figure this one out
        % and put in a book reference.
        if (curEl.sRadius < 0)
            intersectT = (-dot(rays.direction, rays.origin - repCenter, 2) + sqrt(radicand));
        else
            intersectT = (-dot(rays.direction, rays.origin - repCenter, 2) - sqrt(radicand));
        end
        
        %make sure that intersectT is > 0
        if (min(intersectT(:)) < 0)
            fprintf('intersectT less than 0 for lens %i',lensEl);
        end
        
        % Add this segment to the total distance
        %rays.addDistance(intersectT);
        
        % Figure out the new end point position for drawing
        endPoint = rays.endPoint(intersectT);
       
        rtVisualizeRays(obj,rays,nLines,endPoint,lensEl);
        
    else
        % This is an aperture plane.  sRadius == 0
        intersectZ = repmat(curEl.sCenter(3), [nRays 1]);
        intersectT = (intersectZ - rays.origin(:, 3))./rays.direction(:, 3);
        repIntersectT = repmat(intersectT, [1 3]);
        endPoint = rays.origin + rays.direction .* repIntersectT;
        curAperture = min(curEl.apertureD, obj.apertureMiddleD)/2;
        
        % Added for ppsfC aperture tracking
        % If we are using ppsfC's instead of ray objects, we
        % will track the intersection of the rays at the middle
        % of the aperture and save these entries in the ppsfC
        % object.
        if(isa(rays, 'ppsfC'))
            rays.aMiddleInt.XY = 0;
            rays.aMiddleInt.XY = endPoint(:,1:2);  %only X-Y coords
            rays.aMiddleInt.Z  = intersectZ;    %aperture Z
            
            rays.aMiddleDir = rays.direction;
            % passedCenterAperture = true;
        end
    end
    
     
        
    % Set rays outside of the aperture to NaN
    outsideAperture = endPoint(:, 1).^2 + endPoint(:, 2).^2 >= curAperture^2;
    endPoint(outsideAperture, :) = NaN;
    prevN(outsideAperture) = NaN;
    rays.removeDead(outsideAperture);
    
    % Add this segment to the total distance
    rays.addDistance(intersectT.*prevN);     
        
        
    % Apply Snell's law to the spherical surface rays.
    % Determine the new ray directions and origin
    if(curEl.sRadius ~= 0)
        %
        %in bounds case - perform vector Snell's law
        repCenter = repmat(curEl.sCenter, [nRays 1]);
        normalVec = endPoint - repCenter;  %does the polarity of this vector matter? YES
        normalVec = normalVec./repmat(sqrt(sum(normalVec.*normalVec, 2)),[1 3]); %normalizes each row
        
        % Could become the function
        % rtSnell(rays,curEl,normalVec,prevN)
        
        %This is the correct sign convention
        if (curEl.sRadius < 0)
            normalVec = -normalVec;
        end
        
        %liveIndices = ~isnan(rays.waveIndex);
        liveIndices = rays.get('liveIndices');
        curN = ones(size(prevN));
        curN(liveIndices) = curEl.n(rays.waveIndex(liveIndices));  %deal with nans
        curN(~liveIndices) = NaN;
        
        % curN = ones(length(rays.wavelength), 1) * curEl.n;
        % Snell's law index of refraction ratios at surface
        % boundary
        ratio = prevN./curN;
        
        % Vector form of Snell's Law
        c = -dot(normalVec, rays.direction, 2);
        repRatio = repmat(ratio, [1 3]);
        
        %update the direction of the ray
        rays.origin = endPoint;
        
        %plot phase -space for now - deal with
        %subplotting later
        %plot phase space right before the lens, before the rays are bent
        if (lensEl ==1 && nLines > 0)
            rays.plotPhaseSpace();  %this is before the change in position
        end
        
        % Use bsx for speed.
        % Simplify the line
        newVec = repRatio .* rays.direction + ...
            repmat((ratio.*c -sqrt(1 - ratio.^2 .* (1 - c.^2))), [1 3])  .* normalVec;
        rays.direction = newVec;
        rays.normalizeDir();
                
        % newVec2 = newVec./repmat(sqrt(sum(newVec.*newVec, 2)), [1 3]); %normalizes each row
        % vcNewGraphWin; plot(newVec(:),newVec2(:),'.');
        prevN = curN;  %note: curN won't change if the aperture is the overall lens aperture
        
    end
    
    % N.B. No need to update the direction in the case of an
    % aperture.
    
    % HURB diffraction calculation
    if (obj.diffractionEnabled)
        obj.rtHURB(rays, endPoint, curEl.apertureD/2);
    end
end

end

% Let's try to make the lines 3D.  That would be cool!
function rtVisualizeRays(obj,rays,nLines,endPoint,lensEl)
%nLines can be either a number or a structure.  This is
%not completely supported yet.  We don't know if this
%is necessary though. Leave it here for now.

% For the images produced, uses these parameters
lWidth = 0.1; lColor = [0 0.5 1]; lStyle = '-';

samps = rays.drawSamples;

if (isfield(nLines, 'spacing') && isfield(nLines,'numLines'))
    % Structure case.
    %   .spacing is either 'uniform' or 'random'.
    %   .numLines is a positive integer of rays to draw
    if (nLines.numLines > 0)
        if lensEl ==1
            rays.plotHandle = vcNewGraphWin;
            obj.draw();   % Draw the lens
        end
        xCoordVector = [rays.origin(samps,3) endPoint(samps,3) NaN([nLines.numLines 1])]';
        yCoordVector = [rays.origin(samps,2) endPoint(samps,2) NaN([nLines.numLines 1])]';
        xCoordVector = real(xCoordVector(:));
        yCoordVector = real(yCoordVector(:));
        figure(obj.rays.plotHandle);
        line(xCoordVector,  yCoordVector ,'Color',lColor,'LineWidth',lWidth,'LineStyle',lStyle);
        pause(0.1);
    end
else
    %nLines is a number
    % In this case, random sampling is assumed.
    % If nLines = false, or < 0 no drawing happens
    if (nLines > 0)
        if (lensEl ==1)
            rays.plotHandle = vcNewGraphWin;
            obj.draw();
        end
        xCoordVector = [rays.origin(samps,3) endPoint(samps,3) NaN([nLines 1])]';
        yCoordVector = [rays.origin(samps,2) endPoint(samps,2) NaN([nLines 1])]';
        xCoordVector = real(xCoordVector(:));
        yCoordVector = real(yCoordVector(:));
        figure(rays.plotHandle);
        pause(0.1);
        line(xCoordVector,  yCoordVector ,'Color',lColor,'LineWidth',lWidth,'LineStyle',lStyle);
    end
end

end

